<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Example on How to User Contour</title>

    <link rel="stylesheet" href="../examples/css/contour.css">
    <script src="https://code.jquery.com/jquery-2.1.3.js"></script>
    <script src="../examples/js/vendor/d3.js"></script>
    <script src="../examples/js/vendor/lodash.js"></script>
    <script src="../dist/contour.js"></script>

    <style>
        .chart {
            width: 50%;
        }
    </style>

</head>
<body>

    <h2>Contour Multiple Axes Example</h2>

    <button id="data">New Data</button>
    <button id="addSeries">New Series</button>
    <button id="removeSeries">Remove Series</button>
    
    <div class="container">
        <div class="chart"></div>
    </div>

    <script>

    Contour.expose('complex', {

        yAxis: function () {
            if (!this._yAxis || this.curAxis !== this._yAxis.index) {
                this._yAxis = this.axes[this.curAxis || 0].axis()
                    .orient(this.options.yAxis.orient);
                this._yAxis.index = this.curAxis;
            }

            return this._yAxis;
        },

        computeYScale: function () {
            var scaleDomains = _.mapValues(this.yDomainByAxis, function (domain, index) {
                var options = _.merge(this.options, {yAxis:this.options.multiAxes[index]})
                return this._getYScaledDomain(domain, options);
            }, this);

            this.axes = _.mapValues(this.yDomainByAxis, function (domain, index) {
                var options = _.merge(this.options, {yAxis:this.options.multiAxes[index]})
                var type = options.yAxis.type || 'linear';
                return _.nw.yScaleFactory(this.dataSrc, this.options, type, domain);
            }, this);

            this.scales = _.mapValues(this.axes, function (axis, index) {
                return axis.scale(scaleDomains[index]);
            });

            this._changeAxis(0);
        },

        _adjustYDomain: function () {
            var dataVis = _.filter(this._visualizations, function (v) {
                return v.ownData && _.nw.isSupportedDataFormat(v.data);
            });
            var byAxis = _.groupBy(dataVis, function (vis) { return vis.options[vis.type].axis || 0; });
            var extents = _.mapValues(byAxis, function (vis, index) {
                return d3.extent(_.flatten(_.pluck(vis, 'yExtent')));
            });

            if (!extents.hasOwnProperty('0'))
                extents[0] = [0, 10];

            this.yDomainByAxis = extents;
        },

        _setCurrentDomain: function (axisIndex) {
            this.yMin = this.yDomainByAxis[axisIndex][0];
            this.yMax = this.yDomainByAxis[axisIndex][1];
            this.yDomain = this.yDomainByAxis[axisIndex];
        },

        _changeAxis: function (index) {
            this.curAxis = index;
            this._setCurrentDomain(index);
            this.yScale = this.scales[index];
        },

        _renderYAxisElement: function () {
            var options = this.options.yAxis;
            var alignmentOffset = { bottom: '.8em', middle: '.35em', top: '0' };
            var l = 0, r = 0;

            _.forOwn(this.axes, function (axis, index) {
                var pos = (this.options.multiAxes[index] || {}).position || 'left';
                var optOffset = (this.options.multiAxes[index] || {}).offset;
                var offsetFactor =  optOffset != null ? optOffset : 1;
                var axisOffset = offsetFactor * _.nw.sum(this.axesWidths[pos].slice(0, pos === 'left' ? l++ : r++));
                var svgElem = this.svg.selectAll('.multi-axis-' + index);

                if (pos === 'right') {
                    axisOffset = -(axisOffset + this.options.chart.plotWidth);
                }

                if (svgElem.empty()) {
                    svgElem = this._yAxisGroup.append('g');
                }
                
                svgElem.attr('transform', 'translate(' + (-axisOffset) +', 0)')
                    .attr('class', 'multi-axis multi-axis-' + index)
                    .transition().duration(this._animationDuration())
                    .call(axis.axis().orient(pos))
                    .selectAll('.tick text')
                        .attr('dy', alignmentOffset[options.labels.verticalAlign]);

            }, this);
        },

        _calcAxisWidth: function (domain, options) {
            var maxTickSize = function (options) { return Math.max(options.outerTickSize || 0, options.innerTickSize || 0); };
            var yOptions = options.yAxis;
            var interAxisPadding = 5;

            var yDomainScaled = this._getYScaledDomain(domain, options);
            var tmpScale = d3.scale.linear().domain(yDomainScaled);
            var yLabels = tmpScale.ticks(yOptions.ticks);

            var format = yOptions.labels.formatter || d3.format(yOptions.labels.format || ',.0f');
            var yAxisText = _.map(yLabels, format).join('<br>');
            var yLabelBounds = _.nw.textBounds(yAxisText, '.y.axis');
            return maxTickSize(yOptions) + (yOptions.tickPadding || 0) +
                yLabelBounds.width + interAxisPadding;
        },

        _getAdjustedLeftPadding: function () {

            var options = this.options;
            var leftAxisDomains = _.filter(this.yDomainByAxis, function (domain, index) {
                // include anything that is not position === 'right'
                return (options.multiAxes[index] || {}).position !== 'right';
            });

            this.axesWidths = this.axesWidths || {};
            this.axesWidths.left = _.map(leftAxisDomains, function (domain, index) {
                return this._calcAxisWidth.call(this, domain, options);
            }, this);

            return _.nw.sum(this.axesWidths.left) || this.options.chart.padding.left;
        },

        _getAdjustedRightPadding: function () {
            var options = this.options;
            var rightAxisDomains = _.filter(this.yDomainByAxis, function (domain, index) {
                return (options.multiAxes[index] || {}).position === 'right';
            });

            this.axesWidths = this.axesWidths || {};
            this.axesWidths.right = _.map(rightAxisDomains, function (domain, index) {
                return this._calcAxisWidth.call(this, domain, options);
            }, this);

            return _.nw.sum(this.axesWidths.right) || this.options.chart.padding.right;
        },

        renderVisualizations: function () {
            this.curAxis = 0;
            _.each(this._visualizations, function (visualization, index) {
                var visAxis = visualization.options[visualization.type].axis || 0;
                if (visAxis !== this.curAxis) {
                    this._changeAxis(visAxis);
                }

                var id = index + 1;
                var layer = visualization.layer || this.createVisualizationLayer(visualization, id);
                var opt = _.merge({}, this.options, visualization.options);

                layer.attr('transform', 'translate(' + this.options.chart.internalPadding.left + ',' + (this.options.chart.padding.top || 0) + ')');

                visualization.layer = layer;
                visualization.parent = this;
                visualization.render(layer, opt, this);
            }, this);

            return this;
        },

        visualizationIndexes: function(visType) {
            return _.filter(_.map(this._visualizations, function(viz, index) {
                    return viz.type == visType ? index : -1;
                }), 
                function(d) { 
                    return d >= 0
                });
        },

        pushVisualization: function(visType, data, options, insertIndex) {
            this[visType](data, options);
            var instance = this._visualizations.pop();

            if (insertIndex == undefined) {
                insertIndex = 0;
                _.each(this._visualizations, function(viz, index) {
                    if (viz.type == instance.type && insertIndex <= index)
                        insertIndex = index + 1;
                })
            }

            this._visualizations.splice(insertIndex, 0, instance);
            
            if (this.svg) {
                instance.layer = this.svg.insert('g', 'g[vis-id="' + (insertIndex + 1) + '"]');
                instance.layer.attr('vis-id', insertIndex)
                    .attr('vis-type', instance.type);

                this.svg.selectAll('g[vis-id]')
                    .attr('vis-id', function(d, index) { 
                        return index; 
                    });
            }
        },

        popVisualization: function(visIndex) {
            var instance = this._visualizations.splice(visIndex, 1)[0];
            
            if (this.svg) {
                this.svg.select('g[vis-id="' + (visIndex + 1) + '"]').remove();

                this.svg.selectAll('g[vis-id]')
                    .attr('vis-id', function(d, index) { 
                        return index; 
                    });

                this.svg.selectAll('.multi-axis').remove();
            }
        }
    });

    var chart = new Contour({
            el: '.chart',

            xAxis: {
                title: 'some title (kg)',
            },

            yAxis: {
                title: 'other title',
            },

            multiAxes: [{
                position: 'left',
                min: 0,
                max: 100
            }, {
                position: 'right'
            }],

            line: {
                animationDirection: 'bottom-to-top'
            }
        })
        .cartesian()
        .complex()
        .legend()
        .tooltip()

    var renderChart = function() {
        var fullData = [];

        var rawSeries = _.times(10, 1);   
        var indexes = chart.visualizationIndexes('line');
        _.forEach(indexes, function(d) {
            fullData.push({
                name: 'Plot ' + (d+1), 
                data: rawSeries.map(function(val, index) { return { x:index, y:Math.random() * Math.pow(10, d + 1) } })
            });
            chart.select(d).setData([fullData[fullData.length - 1]]);
        })

        chart.select(chart.visualizationIndexes('legend')[0]).setData(fullData);
        chart.select(chart.visualizationIndexes('tooltip')[0]).setData(fullData);
        chart.render();
    }

    var addSeries = function() {
        var indexes = chart.visualizationIndexes('line');
        var index = indexes.length % 2;
        chart.pushVisualization('line', [], { axis: index });
        renderChart();
    }

    window.addEventListener('resize', function() {
        chart.options.chart.animations.enable = false;
        chart.resize().render();
        chart.options.chart.animations.enable = true;
    });

    $('#data').on('click', renderChart);
    
    $('#addSeries').on('click', addSeries);

    $('#removeSeries').on('click', function() {
        var indexes = chart.visualizationIndexes('line');
        chart.popVisualization(indexes[indexes.length - 1]);
        renderChart();
    });
    
    addSeries();
    </script>
</body>
</html>
