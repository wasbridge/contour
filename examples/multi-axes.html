<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Example on How to User Contour</title>

    <link rel="stylesheet" href="../examples/css/contour.css">
    <script src="https://code.jquery.com/jquery-2.1.3.js"></script>
    <script src="../examples/js/vendor/d3.js"></script>
    <script src="../examples/js/vendor/lodash.js"></script>
    <script src="../dist/contour.js"></script>

    <style>
        .chart {
            width: 50%;
        }
    </style>

</head>
<body>

    <h2>Contour Multiple Axes Example</h2>

    <button id="data">New Data</button>
    <button id="addSeries">New Series</button>
    <button id="removeSeries">Remove Series</button>
    
    <div class="container">
        <div class="chart"></div>
    </div>

    <script>

    Contour.expose('complex', {

        yAxis: function () {
            if (!this._yAxis || this.curAxis !== this._yAxis.index) {
                this._yAxis = this.axes[this.curAxis || 0].axis()
                    .orient(this.options.yAxis.orient);
                this._yAxis.index = this.curAxis;
            }

            return this._yAxis;
        },

        computeYScale: function () {
            var scaleDomains = _.map(this.yDomainByAxis, function (domain, index) {
                if (!domain)
                    return undefined;
                var options = _.merge({}, this.options);
                options = _.merge(options, {yAxis:this.options.multiAxes[index]})
                return this._getYScaledDomain(domain, options);
            }, this);

            this.axes = _.map(this.yDomainByAxis, function (domain, index) {
                if (!domain)
                    return undefined;
                var options = _.merge({}, this.options);
                options = _.merge(options, {yAxis:this.options.multiAxes[index]})
                var type = options.yAxis.type || 'linear';
                return _.nw.yScaleFactory(this.dataSrc, options, type, domain);
            }, this);

            this.scales = _.map(this.axes, function (axis, index) {
                return axis ? axis.scale(scaleDomains[index]) : undefined;
            });

            this._changeAxis(0);
        },

        _adjustYDomain: function () {
            var dataVis = _.filter(this._visualizations, function (v) {
                return v.ownData && _.nw.isSupportedDataFormat(v.data);
            });
            var byAxis = _.groupBy(dataVis, function (vis) { return vis.options[vis.type].axis || 0; });
            var byAxisArray = [];
            for (var key in byAxis) {
                if (byAxis.hasOwnProperty(key))
                    byAxisArray[parseInt(key)] = byAxis[key];
            }

            var extents = _.map(byAxisArray, function (vis, index) {
                if (vis)
                    return d3.extent(_.flatten(_.pluck(vis, 'yExtent')));
                else
                    return undefined;
            });

            if (!extents.hasOwnProperty('0'))
                extents[0] = [0, 10];

            this.yDomainByAxis = extents;
        },

        _setCurrentDomain: function (axisIndex) {
            this.yMin = this.yDomainByAxis[axisIndex][0];
            this.yMax = this.yDomainByAxis[axisIndex][1];
            this.yDomain = this.yDomainByAxis[axisIndex];
        },

        _changeAxis: function (index) {
            this.curAxis = index;
            this._setCurrentDomain(index);
            this.yScale = this.scales[index];
        },

        _renderYAxisElement: function () {
            var options = this.options.yAxis;
            var alignmentOffset = { bottom: '.8em', middle: '.35em', top: '0' };
            var l = 0, r = 0;

            _.forEach(this.axes, function (axis, index) {
                if (!axis)
                    return;

                var pos = (this.options.multiAxes[index] || {}).position || 'left';
                var optOffset = (this.options.multiAxes[index] || {}).offset;
                var offsetFactor =  optOffset != null ? optOffset : 1;
                var axisOffset = offsetFactor * _.nw.sum(this.axesWidths[pos].slice(0, pos === 'left' ? l++ : r++));
                var svgElem = this.svg.selectAll('.multi-axis-' + index);

                if (pos === 'right') {
                    axisOffset = -(axisOffset + this.options.chart.plotWidth);
                }

                if (svgElem.empty()) {
                    svgElem = this._yAxisGroup.append('g');
                }
                
                svgElem.attr('transform', 'translate(' + (-axisOffset) +', 0)')
                    .attr('class', 'multi-axis multi-axis-' + index)
                    .transition().duration(this._animationDuration())
                    .call(axis.axis().orient(pos))
                    .selectAll('.tick text')
                        .attr('dy', alignmentOffset[options.labels.verticalAlign]);

            }, this);
        },

        _renderYAxisTitle: function() {
            var adjustFactor = 40/46.609; // this factor is to account for the difference between the actual svg size and what we get from the DOM
            var bounds, x, y, dx, className;
            var el;

            _.forEach(this.axes, function (axis, index) {
                if (!axis)
                    return;

                var options = _.merge({}, this.options);
                options = _.merge(options, {yAxis:options.multiAxes[index]});

                if (options.yAxis.title) {
                    if (options.yAxis.position == "right") {
                        className = 'rightY axis-title';
                        bounds = _.nw.textBounds(options.yAxis.title, '.rightY.axis-title');
                        y = options.chart.plotWidth + options.chart.internalPadding.right - bounds.height * adjustFactor;
                        x = 0
                        dx = -(options.chart.plotHeight + bounds.width) / 2
                        el = this._yAxisGroup.selectAll('.rightY.axis-title').data([1]);
                    } else {
                        className = 'y axis-title';
                        bounds = _.nw.textBounds(options.yAxis.title, '.y.axis-title');
                        y = -options.chart.internalPadding.left + bounds.height * adjustFactor;
                        x = 0;
                        dx = -(options.chart.plotHeight + bounds.width) / 2
                        el = this._yAxisGroup.selectAll('.y.axis-title').data([1]);
                    }
                   
                    if (!el.node()) {
                        el.enter().append('text')
                            .attr('class', className);
                    }

                    d3.select(el.node())
                        .attr('class', className)
                        .attr('transform', 'rotate(-90)')
                        .attr('x', x)
                        .attr('y', y)
                        .attr('dx', dx)
                        .attr('dy', 0)
                        .text(options.yAxis.title);
                }

            }, this);
        },

        _calcAxisWidth: function (domain, options, axisIndex) {
            var maxTickSize = function (options) { return Math.max(options.outerTickSize || 0, options.innerTickSize || 0); };
            options = _.merge({}, options);
            options = _.merge(options, {yAxis:options.multiAxes[axisIndex]});

            var yOptions = options.yAxis;
            var interAxisPadding = 5;

            var yDomainScaled = this._getYScaledDomain(domain, options);
            var tmpScale = d3.scale.linear().domain(yDomainScaled);
            var yLabels = tmpScale.ticks(yOptions.ticks);

            var format = yOptions.labels.formatter || d3.format(yOptions.labels.format || ',.0f');
            var yAxisText = _.map(yLabels, format).join('<br>');
            var yLabelBounds = _.nw.textBounds(yAxisText, '.y.axis');

            
            var titleBounds;
            var width = 0;
            if(yOptions.title) {
                titleBounds = _.nw.textBounds(yOptions.title, '.y.axis-title');
                width += titleBounds.height + yOptions.titlePadding;
            }

            return width + maxTickSize(yOptions) + (yOptions.tickPadding || 0) +
                yLabelBounds.width + interAxisPadding;
        },

        _getAdjustedLeftPadding: function () {
            var options = this.options;
            
            var mappedAxisDomains = _.map(this.yDomainByAxis, function(domain, index) {
                return {domain:domain, index:index};
            });

            var leftAxisDomains = _.filter(mappedAxisDomains, function (domain, index) {
                // include anything that is not position === 'right'
                return (options.multiAxes[index] || {}).position !== 'right';
            });

            this.axesWidths = this.axesWidths || {};
            this.axesWidths.left = _.map(leftAxisDomains, function (obj, index) {
                return this._calcAxisWidth.call(this, obj.domain, options, obj.index);
            }, this);

            return _.nw.sum(this.axesWidths.left) || this.options.chart.padding.left;
        },

        _getAdjustedRightPadding: function () {
            var options = this.options;
            
            var mappedAxisDomains = _.map(this.yDomainByAxis, function(domain, index) {
                return {domain:domain, index:index};
            });

            var rightAxisDomains = _.filter(mappedAxisDomains, function (domain, index) {
                return (options.multiAxes[index] || {}).position === 'right';
            });

            this.axesWidths = this.axesWidths || {};
            this.axesWidths.right = _.map(rightAxisDomains, function (obj, index) {
                return this._calcAxisWidth.call(this, obj.domain, options, obj.index);
            }, this);

            return _.nw.sum(this.axesWidths.right) || this.options.chart.padding.right;
        },

        renderVisualizations: function () {
            this.curAxis = 0;
            _.each(this._visualizations, function (visualization, index) {
                var visAxis = visualization.options[visualization.type].axis || 0;
                if (visAxis !== this.curAxis) {
                    this._changeAxis(visAxis);
                }

                var id = index + 1;
                var layer = visualization.layer || this.createVisualizationLayer(visualization, id);
                var opt = _.merge({}, this.options, visualization.options);

                layer.attr('transform', 'translate(' + this.options.chart.internalPadding.left + ',' + (this.options.chart.padding.top || 0) + ')');

                visualization.layer = layer;
                visualization.parent = this;
                visualization.render(layer, opt, this);
            }, this);

            return this;
        },

        visualizationIndexes: function(visType) {
            return _.filter(_.map(this._visualizations, function(viz, index) {
                    return viz.type == visType ? index : -1;
                }), 
                function(d) { 
                    return d >= 0
                });
        },

        pushVisualization: function(visType, data, options, insertIndex) {
            this[visType](data, options);
            var instance = this._visualizations.pop();

            if (insertIndex == undefined) {
                insertIndex = 0;
                _.each(this._visualizations, function(viz, index) {
                    if (viz.type == instance.type && insertIndex <= index)
                        insertIndex = index + 1;
                })
            }

            this._visualizations.splice(insertIndex, 0, instance);
            
            if (this.svg) {
                instance.layer = this.svg.insert('g', 'g[vis-id="' + (insertIndex + 1) + '"]');
                instance.layer.attr('vis-id', insertIndex)
                    .attr('vis-type', instance.type);

                this.svg.selectAll('g[vis-id]')
                    .attr('vis-id', function(d, index) { 
                        return index; 
                    });
            }
        },

        popVisualization: function(visIndex) {
            var instance = this._visualizations.splice(visIndex, 1)[0];
            
            if (this.svg) {
                this.svg.select('g[vis-id="' + (visIndex + 1) + '"]').remove();

                this.svg.selectAll('g[vis-id]')
                    .attr('vis-id', function(d, index) { 
                        return index; 
                    });

                this.svg.selectAll('.multi-axis').remove();
                this.svg.selectAll('.axis-title').remove();
            }
        }
    });

    var chart = new Contour({
            el: '.chart',

            xAxis: {
                title: 'some title (kg)',
            },

            multiAxes: [{
                position: 'left',
                ticks: 3
            },{
                position: 'right',
                title: 'right'
            },{
                position: 'left',
                title: 'left'
            }],

            line: {
                animationDirection: 'bottom-to-top'
            }
        })
        .cartesian()
        .complex()
        .legend()
        .tooltip()

    var renderChart = function() {
        var fullData = [];

        var rawSeries = _.times(10, 1);   
        var indexes = chart.visualizationIndexes('line');
        _.forEach(indexes, function(d) {
            fullData.push({
                name: 'Plot ' + (d+1), 
                data: rawSeries.map(function(val, index) { return { x:index, y:Math.random() * Math.pow(10, d + 1) } })
            });
            chart.select(d).setData([fullData[fullData.length - 1]]);
        })

        chart.select(chart.visualizationIndexes('legend')[0]).setData(fullData);
        chart.select(chart.visualizationIndexes('tooltip')[0]).setData(fullData);
        chart.render();
    }

    var addSeries = function() {
        var indexes = chart.visualizationIndexes('line');
        var index = indexes.length % 3;
        chart.pushVisualization('line', [], { axis: index });
        renderChart();
    }

    window.addEventListener('resize', function() {
        chart.options.chart.animations.enable = false;
        chart.resize().render();
        chart.options.chart.animations.enable = true;
    });

    $('#data').on('click', renderChart);
    
    $('#addSeries').on('click', addSeries);

    $('#removeSeries').on('click', function() {
        var indexes = chart.visualizationIndexes('line');
        chart.popVisualization(indexes[indexes.length - 1]);
        renderChart();
    });
    
    addSeries();
    addSeries();
    </script>
</body>
</html>
